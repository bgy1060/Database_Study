# 3. SQL - 데이터 모델링

### 1). 데이터 모델링

#### 1. 논리적 모델링 

- 개념적 구조를 정하는 것 (테이블과 컬럼을 어떻게 나누고 컬럼들 사이에 연결 관계는 어떻게 되고 같은 개념적 구조 정하기)



#### 2. 물리적 모델링 

- 개념적인 구조를 바탕으로 실제로 컴퓨터에 데이터베이스를 구축하기 위해 필요한 세부 사항(컬럼 이름, 데이터 타입, 제약조건 등)을 정하는 것



#### 3. 데이터 모델 

- 데이터를 사용하려는 목적에 맞게 정리하고 체계화 시킨 모형
  - **Entity(개체)** : 저장하고 싶은 데이터의 대상, 실제 대상 하나하나(row 하나)
  - **Attribute (속성)** : Entity에 대해서 저장하려는 내용
- 비즈니스 룰에서 entity, attribute, relationship 후보 찾기
  - 모든 명사는 entity 후보다
  - 모든 동사는 relationship 후보다
  - 하나의 값으로 표현할 수 있는 명사는 attribute 후보다
- 하지만 다대다 관계에서는 동사도 entity가 될 수 있다





### 2). 데이터베이스 이상 현상

- 데이터베이스에서 삽입, 업데이트, 삭제를 제대로 할 수 없게 되는 경우
  - **삽입 이상**
    - 새로운 데이터를 자연스럽게 저장할 수 없는 경우
  - **업데이트 이상**  
    - 데이터를 업데이트했을 때, 정확성을 지키기 어려워지는 경우
  - **삭제 이상**  
    - 원하는 데이터만 자연스럽게 삭제할 수 없는 경우
- 데이터베이스 이상 현상이 발생하는 이유는 데이터 모델링을 제대로 하지 않았기 때문





### 3). 정규화

- 데이터베이스의 테이블이 잘 만들어졌는지 평가하고, 잘 만들지 못한 테이블을 고쳐나가는 과정
- 테이블을 정규형이라고 불리는 형태에 부합하게 만들어나감
- **데이터베이스를** 잘 정규화하면 
  - 삽입, 업데이트, 삭제 이상을 없앨 수 있음
  - 새로운 종류의 데이터를 추가할 때 테이블 구조 수정이 많이 없음
  - 데이터베이스 구조를 단순화해서 사용자가 더 쉽게 이해할 수 있음
- 정규화는 데이터 모델을 만들고, 실제 데이터베이스에 구현하기 전에 적용하면 좋음



- **1NF(제 1 정규형)**

  - 테이블 안 모든 로우의 모든 컬럼 값들은 나눌 수 없는 단일 값이어야 한다

  

- **2NF(제 2 정규형)**

  - 1NF(테이블 안 모든 값이 나눌 수 없는 단일 값이어야 한다)에 부합해야 한다
  - 테이블에 candidate key의 일부분에 대해서만 함수 종속성이 있는 non-prime attribute가 없어야 한다
    - **함수 종속성**
      - x에 값에 따라서  y의 값이 결정될 때, y는 x에 함수 종속성이 있다고 한다.
      - 함수 종속성에는 이행성이라는 특성이 있음
      - 하나 이상의 어트리뷰트를 건너서 함수 종속성이 있는 경우에 함수 종속성이 넘어갔다(이행됐다)라고 한다
    - **Candidate Key**
      - 하나의 로우를 특정 지을 수 있는 attribute들의 최소 집합

  

- **3NF(제 3 정규형)**
  - 2NF에 부합해야 한다
  - 테이블 안에 있는 모든 attribute들은 오직 primary key에 대해서만 함수 종속성이 있어야 한다.





### 4). 물리적 모델링

- 데이터베이스에 실제로 저장하는 내용에 최대한 가깝게 데이터 모델을 만드는 과정





### 5). Clustered 인덱스, Non Clustered 인덱스

- **인덱스**

  - 특정 조건의 데이터를 찾는 조회를 굉장히 빠르게 할 수 있음
  - 그렇다고 해서 모든 컬럼과 모든 컬럼의 조합에 인덱스를 추가하지는 않음
  - 인덱스를 너무 많이 사용하면 데이터베이스가 느려질 수 있음
  - 하나의 로우 값을 바꾸면, 해당 컬럼이 포함된 모든 인덱스를 수정해야 함
  - 그래서 인덱스는 조회는 빠르게 할 수 있게 하지만, 삽입, 업데이트, 삭제는 오히려 더 느리게 만들 수 있음

  

- **Clusterted 인덱스** : 테이블 자체를 특정 순서로 저장하는 인덱스
	
	- 조회 속소가 굉장히 빠름
	- 인덱스를 하나밖에 못 만든다
	- 언어 사전과 비슷한 개념
	
	
	
- **Non-Clusterd 인덱스** : 테이블 자체는 그대로 놔두고 다른 곳에 순서를 저장
	
	- 인덱스를 모든 컬럼에 대해서 만들 수 있다
	- Clustered 인덱스보다는 조금 느리다
	- 일반 책의 색인, 또는 인덱스와 비슷한 개념
	
	
